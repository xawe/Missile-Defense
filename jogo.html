<!DOCTYPE html>
<html lang="pt-PT">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Defesa de Mísseis - Arsenal Tático</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
            color: #fff;
            user-select: none;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            text-shadow: 0 0 5px #fff;
            z-index: 10;
        }

        h1 {
            margin: 0;
            font-size: 24px;
            color: #0ff;
        }

        p {
            margin: 5px 0;
            color: #aaa;
        }

        #score-display {
            font-size: 20px;
            color: #ff0;
        }

        #weapon-select {
            margin-top: 15px;
            background: rgba(0, 20, 40, 0.7);
            padding: 10px;
            border: 1px solid #0ff;
            border-radius: 5px;
            pointer-events: auto;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .weapon {
            padding: 5px 10px;
            border: 1px solid #555;
            font-size: 14px;
            color: #777;
            cursor: pointer;
            text-align: center;
        }

        .weapon.active {
            color: #fff;
            background-color: #0055aa;
            border-color: #0ff;
            box-shadow: 0 0 10px #0ff;
        }

        .key-hint {
            font-size: 10px;
            color: #aaa;
            display: block;
            margin-top: 2px;
        }

        #mg-status {
            margin-top: 10px;
            height: 10px;
            width: 100%;
            background: #333;
            display: none;
            border: 1px solid #555;
        }

        #mg-bar {
            height: 100%;
            width: 100%;
            background: #ff0;
            transition: width 0.1s linear;
        }

        .reloading #mg-bar {
            background: #f00;
        }

        #status-text {
            font-size: 12px;
            margin-top: 2px;
            color: #aaa;
        }
    </style>
</head>

<body>

    <div id="ui">
        <h1>DEFESA PLANETÁRIA</h1>
        <p>Clique para disparar.</p>
        <div id="score-display">PONTUAÇÃO: 0</div>

        <div id="weapon-select">
            <div id="w1" class="weapon active" onclick="setWeapon(1)">
                PADRÃO
                <span class="key-hint">[1]</span>
            </div>
            <div id="w2" class="weapon" onclick="setWeapon(2)">
                TELEGUIADO
                <span class="key-hint">[2]</span>
            </div>
            <div id="w3" class="weapon" onclick="setWeapon(3)">
                METRALHADORA
                <span class="key-hint">[3]</span>
            </div>
            <div id="w4" class="weapon" onclick="setWeapon(4)">
                CANHÃO
                <span class="key-hint">[4]</span>
            </div>
            <div id="w5" class="weapon" onclick="setWeapon(5)">
                LASER
                <span class="key-hint">[5]</span>
            </div>
            <div id="w6" class="weapon" onclick="setWeapon(6)">
                UFO
                <span class="key-hint">[6]</span>
            </div>
        </div>

        <div id="mg-status">
            <div id="mg-bar"></div>
        </div>
        <div id="status-text"></div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let score = 0;
        let gameOver = false;
        let frameCount = 0;

        // Entidades do Jogo
        let cities = [];
        let bases = []; // Array para as bases de defesa
        let enemyMissiles = [];
        let playerMissiles = [];
        let explosions = [];
        let particles = [];
        let lasers = [];
        let ufos = [];

        const mouse = { x: 0, y: 0 };

        window.addEventListener('resize', resize);

        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        window.addEventListener('keydown', e => {
            if (['1', '2', '3', '4', '5', '6'].includes(e.key)) {
                setWeapon(parseInt(e.key));
            }
            if (e.code === 'Space') {
                isSpaceDown = true;
            }
        });

        window.addEventListener('keyup', e => {
            if (e.code === 'Space') {
                isSpaceDown = false;
            }
        });

        window.addEventListener('mousedown', e => {
            if (gameOver) {
                resetGame();
            } else {
                isMouseDown = true;
                if (selectedWeapon !== 3) { // Machine gun fires continuously on mouse down
                    attemptFire(e.clientX, e.clientY);
                    lastAutoClickTime = Date.now();
                }
            }
        });

        window.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        function setWeapon(type) {
            selectedWeapon = type;
            document.querySelectorAll('.weapon').forEach(el => el.classList.remove('active'));
            document.getElementById('w' + type).classList.add('active');

            const mgStatus = document.getElementById('mg-status');
            const statusText = document.getElementById('status-text');

            if (type === 3) {
                mgStatus.style.display = 'block';
                // Update UI for the first active base's MG state
                const activeBase = bases.find(b => b.active);
                if (activeBase) updateMgUI(activeBase);
            } else {
                mgStatus.style.display = 'none';
                statusText.innerText = "";
            }

            if (type === 2) {
                statusText.innerText = "Max: 4/Base | +Velocidade/Hit | Alvos Inteligentes";
            } else if (type === 4) {
                statusText.innerText = "Cooldown: 1 segundo";
            } else if (type === 5) {
                statusText.innerText = "Cooldown: 3 segundos | Instakill";
            } else if (type === 1) {
                statusText.innerText = "Velocidade: Standard (Reduzida)";
            } else if (type === 6) {
                statusText.innerText = "Drone Teleportador | Max: 3 | Kamikaze Explosivo";
            }
        }

        function updateMgUI(base) {
            if (selectedWeapon !== 3) return;
            if (!base || !base.active) return; // Only update if base is active

            const bar = document.getElementById('mg-bar');
            const text = document.getElementById('status-text');
            const container = document.getElementById('mg-status');

            const pct = (base.mgAmmo / mgMaxAmmo) * 100;
            bar.style.width = pct + '%';

            if (base.mgOverheated) {
                container.classList.add('reloading');
                text.innerText = "SOBREAQUECIMENTO - A ARREFECER...";
                text.style.color = '#f00';
            } else {
                container.classList.remove('reloading');
                text.innerText = `MUNIÇÃO: ${base.mgAmmo}/${mgMaxAmmo}`;
                text.style.color = '#aaa';
            }
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            if (cities.length > 0) initCities();
            if (bases.length > 0) initBases(); // Reinitialize bases on resize
        }

        class City {
            constructor(x) {
                this.x = x;
                this.y = height - 40;
                this.width = 40;
                this.height = 20;
                this.active = true;
                this.color = '#00ffff';
            }

            draw() {
                if (!this.active) return;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.fillRect(this.x - this.width / 2, this.y, this.width, this.height);

                ctx.fillStyle = '#000';
                ctx.shadowBlur = 0;
                ctx.fillRect(this.x - 10, this.y + 5, 4, 4);
                ctx.fillRect(this.x + 5, this.y + 5, 4, 4);
            }
        }

        class DefenseBase {
            constructor(x, id) {
                this.x = x;
                this.y = height - 10;
                this.radius = 20;
                this.active = true;
                this.color = '#0088ff';
                this.id = id;

                this.hits = 0;
                this.maxHits = 5;
                this.cooldownTimer = 0;

                // Weapon states for this specific base
                this.mgAmmo = mgMaxAmmo;
                this.mgOverheated = false;
                this.cannonLastShot = 0;
                this.laserLastShot = 0;
                this.lastShotTime = 0; // For machine gun rate of fire
            }

            update() {
                if (this.cooldownTimer > 0) {
                    this.cooldownTimer -= 16.67;
                    if (this.cooldownTimer <= 0) {
                        this.active = true;
                        this.cooldownTimer = 0;
                    }
                }
            }

            takeDamage() {
                if (this.hits >= this.maxHits) return;

                this.hits++;
                if (this.hits >= this.maxHits) {
                    this.active = false;
                    createExplosion(this.x, this.y, '#ff0000', true);
                } else {
                    this.active = false;
                    this.cooldownTimer = 2000;
                }
            }

            draw() {
                if (this.hits >= this.maxHits) return;

                if (this.cooldownTimer > 0) {
                    // Blink effect: alternate colors every 100ms
                    if (Math.floor(Date.now() / 100) % 2 === 0) {
                        ctx.fillStyle = '#555'; // Disabled color
                    } else {
                        ctx.fillStyle = '#ff5500'; // Warning color
                    }
                } else {
                    ctx.fillStyle = this.active ? this.color : '#555';
                }

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, Math.PI, 0);
                ctx.fill();
            }

            startMgCooldown() {
                this.mgOverheated = true;
                updateMgUI(this);
                setTimeout(() => {
                    this.mgAmmo = mgMaxAmmo;
                    this.mgOverheated = false;
                    updateMgUI(this);
                }, 2000);
            }

            fireMissile(targetX, targetY, type) {
                if (targetY > height - 50) targetY = height - 50;

                if (type === 3) {
                    targetX += (Math.random() * 40 - 20);
                    targetY += (Math.random() * 40 - 20);
                }

                // Pass this.id as the sourceId
                playerMissiles.push(new PlayerMissile(this.x, this.y, targetX, targetY, type, 0, this.id));
            }

            fireCannonSpread(targetX, targetY) {
                if (targetY > height - 50) targetY = height - 50;
                const spreadAngles = [-0.2, -0.1, 0, 0.1, 0.2];
                spreadAngles.forEach(angleOffset => {
                    playerMissiles.push(new PlayerMissile(this.x, this.y, targetX, targetY, 4, angleOffset, this.id));
                });
            }

            fireLaser(targetX, targetY) {
                lasers.push(new LaserBeam(this.x, this.y, targetX, targetY));
            }
        }

        class LaserBeam {
            constructor(startX, startY, targetX, targetY, isShortRange = false) {
                this.startX = startX;
                this.startY = startY;

                const angle = Math.atan2(targetY - this.startY, targetX - this.startX);

                let length = Math.max(width, height) * 1.5;
                if (isShortRange) length = Math.hypot(targetX - startX, targetY - startY); // Exact distance for short range

                this.endX = this.startX + Math.cos(angle) * length;
                this.endY = this.startY + Math.sin(angle) * length;

                this.life = 1.0;
                this.decay = 0.012; // Aumenta o tempo de ação do laser
                if (isShortRange) this.decay = 0.1; // Short range lasers fade faster

                this.active = true;
                this.width = isShortRange ? 2 : 4;
                this.color = isShortRange ? '#00ff00' : '#ff00ff';
            }

            update() {
                this.life -= this.decay;
                if (this.life <= 0) this.active = false;
            }

            draw() {
                if (!this.active) return;

                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.globalCompositeOperation = 'lighter';

                ctx.beginPath();
                ctx.moveTo(this.startX, this.startY);
                ctx.lineTo(this.endX, this.endY);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = this.width;
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(this.startX, this.startY);
                ctx.lineTo(this.endX, this.endY);
                ctx.strokeStyle = this.color;
                ctx.lineWidth = this.width * 4;
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.color;
                ctx.stroke();

                ctx.restore();
            }
        }

        class UFO {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.range = 250;
                this.active = true;
                this.lastShot = 0;
                this.fireRate = 500; // ms
                this.radius = 15;

                this.teleportTimer = Date.now();
                this.teleportInterval = 5000; // 5 seconds
            }

            update() {
                // Teleport Logic
                if (Date.now() - this.teleportTimer > this.teleportInterval) {
                    this.teleport();
                    this.teleportTimer = Date.now();
                }

                // Attack Logic (Stationary Turret)
                if (Date.now() - this.lastShot > this.fireRate) {
                    // Find closest enemy in range
                    let closest = null;
                    let minDist = this.range;

                    enemyMissiles.forEach(e => {
                        if (!e.active) return;
                        const dist = Math.hypot(e.x - this.x, e.y - this.y);
                        if (dist < minDist) {
                            minDist = dist;
                            closest = e;
                        }
                    });

                    if (closest) {
                        lasers.push(new LaserBeam(this.x, this.y, closest.x, closest.y, true));
                        this.lastShot = Date.now();
                    }
                }
            }

            teleport() {
                // Teleport to a random position in the upper 2/3 of the screen
                this.x = Math.random() * width;
                this.y = Math.random() * (height * 0.6);

                // Visual effect for teleport arrival
                createExplosion(this.x, this.y, '#00ffaa', false);
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                // Draw UFO body
                ctx.fillStyle = '#00ffaa';
                ctx.beginPath();
                ctx.ellipse(0, 0, 20, 8, 0, 0, Math.PI * 2);
                ctx.fill();

                // Dome
                ctx.fillStyle = 'rgba(200, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(0, -3, 8, Math.PI, 0);
                ctx.fill();

                // Lights
                if (Math.floor(Date.now() / 200) % 2 === 0) {
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(-10, 0, 2, 0, Math.PI * 2);
                    ctx.arc(10, 0, 2, 0, Math.PI * 2);
                    ctx.arc(0, 4, 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        // Classe de Partículas Base (Detritos)
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 4 + 1;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1;
                this.decay = Math.random() * 0.03 + 0.01;
                this.color = color;
                this.active = true;
                this.gravity = 0.08;
                this.size = 3;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.vx *= 0.95;
                this.vy *= 0.95;
                this.life -= this.decay;
                if (this.life <= 0) this.active = false;
            }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1.0;
            }
        }

        // Nova Classe de Partículas: Fogo/Chama
        class FireParticle extends Particle {
            constructor(x, y) {
                // Chama o construtor base, mas força cor amarela/laranja
                super(x, y, `rgb(${255}, ${Math.floor(Math.random() * 150 + 100)}, 0)`);
                this.vy = Math.random() * -3 - 1; // Fogo sobe mais rápido
                this.vx /= 2; // Movimento horizontal mais lento
                this.gravity = -0.05; // Leve ascensão
                this.decay = 0.04;
                this.size = Math.random() * 4 + 2;
            }
            update() {
                super.update();
                // O fogo deve encolher
                this.size = Math.max(0.5, this.size - 0.1);
            }
        }

        // Nova Classe de Partículas: Fumo
        class SmokeParticle extends Particle {
            constructor(x, y) {
                // Fumo é cinzento
                const gray = Math.floor(Math.random() * 50 + 50);
                super(x, y, `rgb(${gray}, ${gray}, ${gray})`);
                this.vy /= 5; // Move-se devagar
                this.gravity = 0; // Quase sem gravidade
                this.decay = 0.01; // Dura muito mais
                this.size = Math.random() * 5 + 3;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.99;
                this.vy *= 0.99;
                // O fumo deve expandir-se
                this.size += 0.1;
                this.life -= this.decay;
                if (this.life <= 0) this.active = false;
            }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life * 0.5); // Fumo é translúcido
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class Explosion {
            constructor(x, y, color, maxRadius = 70) {
                this.x = x;
                this.y = y;
                this.radius = 1;
                this.maxRadius = maxRadius;
                this.growthRate = 2;
                this.life = 1;
                this.decay = 0.04;
                this.color = color || '#ffffff';
                this.active = true;
            }
            update() {
                if (this.radius < this.maxRadius) {
                    this.radius += this.growthRate;
                } else {
                    this.life -= this.decay;
                }
                if (this.life <= 0) this.active = false;
            }
            draw() {
                // Desenha o flash branco inicial (maior)
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${this.life * 0.3})`;
                ctx.fill();
                // Desenha o núcleo de cor (mais pequeno)
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 0.7, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = this.life;
                ctx.fill();
                ctx.globalAlpha = 1.0;
                ctx.globalCompositeOperation = 'source-over';
            }
        }

        class EnemyMissile {
            constructor() {
                this.startX = Math.random() * width;
                this.startY = 0;
                this.x = this.startX;
                this.y = this.startY;
                let targetX;
                // Prioritize cities, then bases
                const activeTargets = [...cities.filter(c => c.active), ...bases.filter(b => b.active)];

                if (activeTargets.length > 0 && Math.random() > 0.3) {
                    const target = activeTargets[Math.floor(Math.random() * activeTargets.length)];
                    targetX = target.x;
                } else {
                    targetX = Math.random() * width;
                }

                this.targetY = height;
                this.speed = ((Math.random() * 1.5 + 0.5) * difficultyMultiplier) * 0.7;

                const angle = Math.atan2(this.targetY - this.startY, targetX - this.startX);
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;

                this.active = true;
                this.color = '#ff0055';
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                if (this.y >= height - 20) { // Impact ground level
                    this.active = false;
                    createExplosion(this.x, height - 20, '#ffaa00', true); // Explosão no chão
                    checkCityCollision(this.x);
                    checkBaseCollision(this.x); // Check for base collision
                }
            }

            draw() {
                ctx.beginPath();
                ctx.moveTo(this.startX, this.startY);
                ctx.lineTo(this.x, this.y);
                ctx.strokeStyle = `rgba(255, 0, 85, 0.5)`;
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.fillRect(this.x - 1, this.y - 1, 3, 3);
            }
        }

        class PlayerMissile {
            constructor(startX, startY, targetX, targetY, type, angleOffset = 0, sourceId = null) {
                this.startX = startX;
                this.startY = startY;
                this.x = this.startX;
                this.y = this.startY;
                this.targetX = targetX;
                this.targetY = targetY;
                this.type = type;
                this.active = true;
                this.sourceId = sourceId; // Store the ID of the base that fired this

                this.creationTime = Date.now();
                this.target = null;

                if (type === 1) {
                    this.speed = 7.5;
                    this.color = '#00ffff';
                } else if (type === 2) {
                    this.speed = 3.92 * homingMissileSpeedMultiplier; // Apply speed multiplier
                    this.color = '#00ff00';
                    this.turnSpeed = 0.016;
                    this.maxFlightTime = 7000;
                } else if (type === 3) {
                    this.speed = 6;
                    this.color = '#ffff00';
                } else if (type === 4) {
                    this.speed = 5;
                    this.color = '#ff8800';
                }

                let angle = Math.atan2(targetY - this.startY, targetX - this.startX);
                angle += angleOffset;

                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
            }

            update() {
                if (this.type === 2) {
                    // Lógica de Tempo de Voo
                    if (Date.now() - this.creationTime > this.maxFlightTime) {
                        this.active = false;
                        createExplosion(this.x, this.y, this.color, false);
                        return;
                    }

                    // --- LÓGICA DE ALVO INTELIGENTE ---
                    if (!this.target || !this.target.active) {
                        this.target = null;

                        const otherHomingMissiles = playerMissiles.filter(p => p !== this && p.active && p.type === 2 && p.target);
                        const busyTargets = otherHomingMissiles.map(p => p.target);

                        let candidates = enemyMissiles.filter(e => e.active && !busyTargets.includes(e));
                        if (candidates.length === 0) candidates = enemyMissiles.filter(e => e.active);

                        let closestDist = Infinity;
                        candidates.forEach(enemy => {
                            const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                            if (dist < closestDist) {
                                closestDist = dist;
                                this.target = enemy;
                            }
                        });
                    }

                    if (this.target) {
                        const targetAngle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                        const currentAngle = Math.atan2(this.vy, this.vx);
                        let angleDiff = targetAngle - currentAngle;
                        while (angleDiff <= -Math.PI) angleDiff += Math.PI * 2;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;

                        let newAngle = currentAngle;
                        if (Math.abs(angleDiff) < this.turnSpeed) {
                            newAngle = targetAngle;
                        } else {
                            newAngle += Math.sign(angleDiff) * this.turnSpeed;
                        }
                        this.vx = Math.cos(newAngle) * this.speed;
                        this.vy = Math.sin(newAngle) * this.speed;
                    }
                }

                this.x += this.vx;
                this.y += this.vy;

                if (this.type === 1) {
                    const distToTarget = Math.hypot(this.x - this.targetX, this.y - this.targetY);
                    if (distToTarget < this.speed || (this.vy < 0 && this.y <= this.targetY)) {
                        this.active = false;
                        createExplosion(this.targetX, this.targetY, this.color, false);
                    }
                } else {
                    if (this.x < 0 || this.x > width || this.y < 0 || this.y > height) {
                        this.active = false;
                    }
                }
            }

            draw() {
                ctx.beginPath();
                if (this.type === 1 || this.type === 4) {
                    ctx.moveTo(this.startX, this.startY);
                    ctx.lineTo(this.x, this.y);
                } else {
                    ctx.moveTo(this.x - this.vx * 3, this.y - this.vy * 3);
                    ctx.lineTo(this.x, this.y);
                }

                ctx.strokeStyle = this.color;
                ctx.lineWidth = (this.type === 3) ? 1 : (this.type === 4 ? 3 : 2);
                ctx.stroke();

                ctx.fillStyle = '#fff';
                const size = this.type === 3 ? 2 : 3;
                ctx.fillRect(this.x - size / 2, this.y - size / 2, size, size);
            }
        }

        // Funções Auxiliares

        function initCities() {
            cities = [];
            const spacing = width / 7;
            for (let i = 1; i <= 6; i++) {
                cities.push(new City(spacing * i));
            }
        }

        function initBases() {
            bases = [];
            // Esquerda, Centro, Direita
            bases.push(new DefenseBase(50, 0));
            bases.push(new DefenseBase(width / 2, 1));
            bases.push(new DefenseBase(width - 50, 2));
        }

        function attemptFire(x, y) {
            const now = Date.now();
            // Find the closest active base
            let closestBase = null;
            let minDist = Infinity;
            bases.forEach(base => {
                if (base.active) {
                    const dist = Math.abs(x - base.x);
                    if (dist < minDist) {
                        minDist = dist;
                        closestBase = base;
                    }
                }
            });

            if (!closestBase) return; // No active bases to fire from

            if (selectedWeapon === 2) {
                // Check how many homing missiles are active from THIS base
                const activeHomingFromBase = playerMissiles.filter(p => p.active && p.type === 2 && p.sourceId === closestBase.id).length;

                if (activeHomingFromBase >= 4) return; // Limit 4 per base

                closestBase.fireMissile(x, y, 2);
            }
            else if (selectedWeapon === 3) {
                if (closestBase.mgOverheated) return;
                if (now - closestBase.lastShotTime > 100) {
                    if (closestBase.mgAmmo > 0) {
                        closestBase.mgAmmo--;
                        closestBase.fireMissile(x, y, 3);
                        closestBase.lastShotTime = now;
                        updateMgUI(closestBase);
                    }
                    if (closestBase.mgAmmo <= 0 && !closestBase.mgOverheated) {
                        closestBase.startMgCooldown();
                    }
                }
            }
            else if (selectedWeapon === 4) {
                if (now - closestBase.cannonLastShot > cannonCooldown) {
                    closestBase.fireCannonSpread(x, y);
                    closestBase.cannonLastShot = now;
                }
            }
            else if (selectedWeapon === 5) {
                if (now - closestBase.laserLastShot > laserCooldown) {
                    closestBase.fireLaser(x, y);
                    closestBase.laserLastShot = now;
                }
            }
            else if (selectedWeapon === 6) {
                // Limit to 3 active UFOs
                if (ufos.length < 3) {
                    ufos.push(new UFO(closestBase.x, closestBase.y - 30));
                }
            }
            else { // Default weapon (type 1)
                closestBase.fireMissile(x, y, 1);
            }
        }

        function createExplosion(x, y, color, isGroundImpact = false) {
            const radius = isGroundImpact ? 80 : 70; // Explosões no chão são maiores
            explosions.push(new Explosion(x, y, color, radius));

            // Adiciona 50 partículas de detritos (Branco/Cor base)
            for (let i = 0; i < 50; i++) {
                particles.push(new Particle(x, y, color));
            }

            // Adiciona 30 partículas de Fogo (vermelho/amarelo)
            for (let i = 0; i < 30; i++) {
                particles.push(new FireParticle(x, y));
            }

            // Adiciona 20 partículas de Fumo (cinzento)
            for (let i = 0; i < 20; i++) {
                particles.push(new SmokeParticle(x, y));
            }
        }

        function checkBaseCollision(impactX) {
            bases.forEach(base => {
                if (base.active && Math.abs(impactX - base.x) < base.radius) {
                    base.takeDamage();
                }
            });
        }

        function checkCityCollision(impactX) {
            cities.forEach(city => {
                if (city.active && Math.abs(impactX - city.x) < 30) {
                    city.active = false;
                    for (let k = 0; k < 5; k++) {
                        setTimeout(() => {
                            // Cria explosões secundárias nas cidades destruídas com fogo e fumo
                            createExplosion(city.x + (Math.random() * 20 - 10), city.y - (Math.random() * 10), '#ff0000', true);
                        }, k * 100);
                    }
                }
            });
        }

        function distToSegment(p, v, w) {
            function sqr(x) { return x * x }
            function dist2(v, w) { return sqr(v.x - w.x) + sqr(v.y - w.y) }
            let l2 = dist2(v, w);
            if (l2 == 0) return Math.sqrt(dist2(p, v));
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            return Math.sqrt(dist2(p, { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) }));
        }

        function checkCollisions() {
            // 1. Explosões
            explosions.forEach(exp => {
                if (!exp.active) return;
                enemyMissiles.forEach(enemy => {
                    if (!enemy.active) return;
                    const dist = Math.hypot(enemy.x - exp.x, enemy.y - exp.y);
                    if (dist < exp.radius) {
                        enemy.active = false;
                        score += 100;
                        createExplosion(enemy.x, enemy.y, '#ffaa00', false);
                    }
                });
            });

            // 2. Mísseis Físicos
            playerMissiles.forEach(pm => {
                if (!pm.active || pm.type === 1) return;

                enemyMissiles.forEach(enemy => {
                    if (!enemy.active) return;
                    const dist = Math.hypot(pm.x - enemy.x, pm.y - enemy.y);
                    const hitRadius = (pm.type === 4) ? 25 : 15;

                    if (dist < hitRadius) {
                        enemy.active = false;
                        pm.active = false;
                        score += 150;
                        createExplosion(enemy.x, enemy.y, '#ffaa00', false);

                        // Increase homing missile speed on hit
                        if (pm.type === 2) {
                            homingMissileSpeedMultiplier += 0.001;
                        }
                    }
                });
            });

            // 3. Lasers
            lasers.forEach(laser => {
                if (!laser.active) return;
                enemyMissiles.forEach(enemy => {
                    if (!enemy.active) return;

                    const dist = distToSegment(
                        { x: enemy.x, y: enemy.y },
                        { x: laser.startX, y: laser.startY },
                        { x: laser.endX, y: laser.endY }
                    );

                    if (dist < 10) {
                        enemy.active = false;
                        score += 200;
                        createExplosion(enemy.x, enemy.y, '#ff00ff', false);
                    }
                });
            });

            // 4. UFO Collisions
            ufos.forEach(ufo => {
                if (!ufo.active) return;

                enemyMissiles.forEach(enemy => {
                    if (!enemy.active) return;
                    const dist = Math.hypot(ufo.x - enemy.x, ufo.y - enemy.y);

                    if (dist < ufo.radius + 5) { // Collision!
                        ufo.active = false;
                        enemy.active = false;

                        // Massive explosion
                        const blastRadius = width * 0.20;
                        createExplosion(ufo.x, ufo.y, '#00ffaa', false); // Visual explosion

                        // Kill everything in radius
                        enemyMissiles.forEach(e => {
                            if (e.active && Math.hypot(e.x - ufo.x, e.y - ufo.y) < blastRadius) {
                                e.active = false;
                                createExplosion(e.x, e.y, '#ffaa00', false);
                                score += 50;
                            }
                        });

                        // Visual shockwave for massive explosion
                        explosions.push(new Explosion(ufo.x, ufo.y, '#ffffff', blastRadius));
                    }
                });
            });
        }

        function resetGame() {
            score = 0;
            difficultyMultiplier = 1;
            frameCount = 0;
            enemyMissiles = [];
            playerMissiles = [];
            explosions = [];
            particles = [];
            lasers = [];
            ufos = [];
            homingMissileSpeedMultiplier = 1; // Reset speed multiplier

            initBases(); // Reinitialize bases
            initCities();
            gameOver = false;
            loop();
        }

        function updateScore() {
            document.getElementById('score-display').innerText = `PONTUAÇÃO: ${score}`;
        }

        function loop() {
            if (gameOver) return;

            // Rastro
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, width, height);

            // Atualiza e desenha a UI da metralhadora para a base selecionada
            const activeBase = bases.find(b => b.active); // Find any active base to display UI
            if (activeBase) {
                updateMgUI(activeBase);
            }

            // AUTO-FIRE LOGIC
            if (isMouseDown || isSpaceDown) {
                if (selectedWeapon === 3) {
                    attemptFire(mouse.x, mouse.y);
                } else {
                    if (Date.now() - lastAutoClickTime > autoClickRate) {
                        attemptFire(mouse.x, mouse.y);
                        lastAutoClickTime = Date.now();
                    }
                }
            }

            if (cities.every(c => !c.active) && bases.every(b => b.hits >= b.maxHits)) { // Game over if all cities AND bases are destroyed
                gameOver = true;
                ctx.fillStyle = 'white';
                ctx.font = '40px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText("FIM DE JOGO", width / 2, height / 2);
                ctx.font = '20px Courier New';
                ctx.fillText("Clique para Reiniciar", width / 2, height / 2 + 40);
                return;
            }

            if (frameCount % Math.max(20, 100 - Math.floor(score / 500)) === 0) {
                enemyMissiles.push(new EnemyMissile());
                // Limit speed increase to 30% (max multiplier 1.3)
                difficultyMultiplier = Math.min(1.3, 1 + (score / 5000));
            }

            // A ordem de desenho é crucial para o efeito de fogo/fumo.

            // 1. Partículas (Fumo/Fogo/Detritos)
            particles.forEach((p, index) => {
                p.update();
                p.draw();
                if (!p.active) particles.splice(index, 1);
            });

            // 2. Explosões (Núcleo Brilhante)
            explosions.forEach((e, index) => {
                e.update();
                e.draw();
                if (!e.active) explosions.splice(index, 1);
            });

            // 3. Mísseis e Laser (Em cima de tudo)
            lasers.forEach((l, index) => {
                l.update();
                l.draw();
                if (!l.active) lasers.splice(index, 1);
            });

            enemyMissiles.forEach((m, index) => {
                m.update();
                m.draw();
                if (!m.active) enemyMissiles.splice(index, 1);
            });

            playerMissiles.forEach((m, index) => {
                m.update();
                m.draw();
                if (!m.active) playerMissiles.splice(index, 1);
            });

            ufos.forEach((u, index) => {
                u.update();
                u.draw();
                if (!u.active) ufos.splice(index, 1);
            });

            // 4. Cidades e Bases
            cities.forEach(city => city.draw());

            bases.forEach(base => {
                base.update();
                base.draw();
            });

            ctx.fillStyle = '#333';
            ctx.fillRect(0, height - 20, width, 20);

            checkCollisions();
            updateScore();
            frameCount++;
            requestAnimationFrame(loop);
        }

        resize();
        initCities();
        initBases(); // Initialize bases
        updateMgUI(bases[0]); // Initialize UI with first base's state
        loop();

    </script>
</body>

</html>

playerMissiles.forEach((m, index) => {
m.update();
m.draw();
if (!m.active) playerMissiles.splice(index, 1);
});

ufos.forEach((u, index) => {
u.update();
u.draw();
if (!u.active) ufos.splice(index, 1);
});

// 4. Cidades e Bases
cities.forEach(city => city.draw());

bases.forEach(base => {
base.update();
base.draw();
});

ctx.fillStyle = '#333';
ctx.fillRect(0, height - 20, width, 20);

checkCollisions();
updateScore();
frameCount++;
requestAnimationFrame(loop);
}

resize();
initCities();
initBases(); // Initialize bases
updateMgUI(bases[0]); // Initialize UI with first base's state
loop();

</script>
</body>

</html>