<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Defesa de Mísseis - Arsenal Tático</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
            color: #fff;
            user-select: none;
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            text-shadow: 0 0 5px #fff;
            z-index: 10;
        }
        h1 {
            margin: 0;
            font-size: 24px;
            color: #0ff;
        }
        p {
            margin: 5px 0;
            color: #aaa;
        }
        #score-display {
            font-size: 20px;
            color: #ff0;
        }
        #weapon-select {
            margin-top: 15px;
            background: rgba(0, 20, 40, 0.7);
            padding: 10px;
            border: 1px solid #0ff;
            border-radius: 5px;
            pointer-events: auto;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .weapon {
            padding: 5px 10px;
            border: 1px solid #555;
            font-size: 14px;
            color: #777;
            cursor: pointer;
            text-align: center;
        }
        .weapon.active {
            color: #fff;
            background-color: #0055aa;
            border-color: #0ff;
            box-shadow: 0 0 10px #0ff;
        }
        .key-hint {
            font-size: 10px;
            color: #aaa;
            display: block;
            margin-top: 2px;
        }
        
        #mg-status {
            margin-top: 10px;
            height: 10px;
            width: 100%;
            background: #333;
            display: none;
            border: 1px solid #555;
        }
        #mg-bar {
            height: 100%;
            width: 100%;
            background: #ff0;
            transition: width 0.1s linear;
        }
        .reloading #mg-bar {
            background: #f00;
        }
        #status-text {
            font-size: 12px;
            margin-top: 2px;
            color: #aaa;
        }
    </style>
</head>
<body>

    <div id="ui">
        <h1>DEFESA PLANETÁRIA</h1>
        <p>Clique para disparar.</p>
        <div id="score-display">PONTUAÇÃO: 0</div>
        
        <div id="weapon-select">
            <div id="w1" class="weapon active" onclick="setWeapon(1)">
                PADRÃO
                <span class="key-hint">[1]</span>
            </div>
            <div id="w2" class="weapon" onclick="setWeapon(2)">
                TELEGUIADO
                <span class="key-hint">[2]</span>
            </div>
            <div id="w3" class="weapon" onclick="setWeapon(3)">
                METRALHADORA
                <span class="key-hint">[3]</span>
            </div>
            <div id="w4" class="weapon" onclick="setWeapon(4)">
                CANHÃO
                <span class="key-hint">[4]</span>
            </div>
            <div id="w5" class="weapon" onclick="setWeapon(5)">
                LASER
                <span class="key-hint">[5]</span>
            </div>
        </div>

        <div id="mg-status">
            <div id="mg-bar"></div>
        </div>
        <div id="status-text"></div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let score = 0;
        let gameOver = false;
        let frameCount = 0;
        let difficultyMultiplier = 1;

        // Estados de Input e Armas
        let selectedWeapon = 1; 
        let isMouseDown = false;
        let lastShotTime = 0;

        // Configurações Específicas de Armas
        let mgAmmo = 20;
        const mgMaxAmmo = 20;
        let mgOverheated = false;
        
        let cannonLastShot = 0;
        const cannonCooldown = 1000; 
        
        let laserLastShot = 0;
        const laserCooldown = 3000; 

        // Entidades do Jogo
        let cities = [];
        let enemyMissiles = [];
        let playerMissiles = [];
        let explosions = [];
        let particles = []; 
        let lasers = []; 
        
        const mouse = { x: 0, y: 0 };

        window.addEventListener('resize', resize);
        
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        window.addEventListener('keydown', e => {
            if (['1', '2', '3', '4', '5'].includes(e.key)) {
                setWeapon(parseInt(e.key));
            }
        });

        window.addEventListener('mousedown', e => {
            if (gameOver) {
                resetGame();
            } else {
                isMouseDown = true;
                if (selectedWeapon !== 3) {
                    attemptFire(e.clientX, e.clientY);
                }
            }
        });

        window.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        function setWeapon(type) {
            selectedWeapon = type;
            document.querySelectorAll('.weapon').forEach(el => el.classList.remove('active'));
            document.getElementById('w' + type).classList.add('active');
            
            const mgStatus = document.getElementById('mg-status');
            const statusText = document.getElementById('status-text');
            
            if (type === 3) {
                mgStatus.style.display = 'block';
                updateMgUI();
            } else {
                mgStatus.style.display = 'none';
                statusText.innerText = "";
            }

            if (type === 2) {
                statusText.innerText = "Max: 4 | Tempo Limite: 7s | Alvos Inteligentes";
            } else if (type === 4) {
                statusText.innerText = "Cooldown: 1 segundo";
            } else if (type === 5) {
                statusText.innerText = "Cooldown: 3 segundos | Instakill";
            } else if (type === 1) {
                statusText.innerText = "Velocidade: Standard (Reduzida)";
            }
        }

        function updateMgUI() {
            if (selectedWeapon !== 3) return;
            
            const bar = document.getElementById('mg-bar');
            const text = document.getElementById('status-text');
            const container = document.getElementById('mg-status');
            
            const pct = (mgAmmo / mgMaxAmmo) * 100;
            bar.style.width = pct + '%';
            
            if (mgOverheated) {
                container.classList.add('reloading');
                text.innerText = "SOBREAQUECIMENTO - A ARREFECER...";
                text.style.color = '#f00';
            } else {
                container.classList.remove('reloading');
                text.innerText = `MUNIÇÃO: ${mgAmmo}/${mgMaxAmmo}`;
                text.style.color = '#aaa';
            }
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            if (cities.length > 0) initCities();
        }

        class City {
            constructor(x) {
                this.x = x;
                this.y = height - 40;
                this.width = 40;
                this.height = 20;
                this.active = true;
                this.color = '#00ffff';
            }

            draw() {
                if (!this.active) return;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.fillRect(this.x - this.width/2, this.y, this.width, this.height);
                
                ctx.fillStyle = '#000';
                ctx.shadowBlur = 0;
                ctx.fillRect(this.x - 10, this.y + 5, 4, 4);
                ctx.fillRect(this.x + 5, this.y + 5, 4, 4);
            }
        }

        class LaserBeam {
            constructor(targetX, targetY) {
                this.startX = width / 2;
                this.startY = height - 20;
                
                const angle = Math.atan2(targetY - this.startY, targetX - this.startX);
                
                const length = Math.max(width, height) * 1.5;
                this.endX = this.startX + Math.cos(angle) * length;
                this.endY = this.startY + Math.sin(angle) * length;
                
                this.life = 1.0; 
                this.decay = 0.012; // Aumenta o tempo de ação do laser
                this.active = true;
                this.width = 4;
            }

            update() {
                this.life -= this.decay;
                if (this.life <= 0) this.active = false;
            }

            draw() {
                if (!this.active) return;
                
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.globalCompositeOperation = 'lighter';
                
                ctx.beginPath();
                ctx.moveTo(this.startX, this.startY);
                ctx.lineTo(this.endX, this.endY);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = this.width;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(this.startX, this.startY);
                ctx.lineTo(this.endX, this.endY);
                ctx.strokeStyle = '#ff00ff'; 
                ctx.lineWidth = this.width * 4;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ff00ff';
                ctx.stroke();
                
                ctx.restore();
            }
        }
        
        // Classe de Partículas Base (Detritos)
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 4 + 1; 
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1; 
                this.decay = Math.random() * 0.03 + 0.01; 
                this.color = color;
                this.active = true;
                this.gravity = 0.08; 
                this.size = 3;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                
                this.vy += this.gravity; 
                this.vx *= 0.95; 
                this.vy *= 0.95; 

                this.life -= this.decay;
                if (this.life <= 0) this.active = false;
            }

            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1.0;
            }
        }

        // Nova Classe de Partículas: Fogo/Chama
        class FireParticle extends Particle {
            constructor(x, y) {
                // Chama o construtor base, mas força cor amarela/laranja
                super(x, y, `rgb(${255}, ${Math.floor(Math.random() * 150 + 100)}, 0)`);
                this.vy = Math.random() * -3 - 1; // Fogo sobe mais rápido
                this.vx /= 2; // Movimento horizontal mais lento
                this.gravity = -0.05; // Leve ascensão
                this.decay = 0.04;
                this.size = Math.random() * 4 + 2;
            }

            update() {
                super.update();
                // O fogo deve encolher
                this.size = Math.max(0.5, this.size - 0.1); 
            }
        }

        // Nova Classe de Partículas: Fumo
        class SmokeParticle extends Particle {
            constructor(x, y) {
                // Fumo é cinzento
                const gray = Math.floor(Math.random() * 50 + 50);
                super(x, y, `rgb(${gray}, ${gray}, ${gray})`);
                this.vy /= 5; // Move-se devagar
                this.gravity = 0; // Quase sem gravidade
                this.decay = 0.01; // Dura muito mais
                this.size = Math.random() * 5 + 3;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.99;
                this.vy *= 0.99;
                
                // O fumo deve expandir-se
                this.size += 0.1; 
                
                this.life -= this.decay;
                if (this.life <= 0) this.active = false;
            }

            draw() {
                ctx.globalAlpha = Math.max(0, this.life * 0.5); // Fumo é translúcido
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class Explosion {
            constructor(x, y, color, maxRadius = 70) { // Aumenta ligeiramente o raio
                this.x = x;
                this.y = y;
                this.radius = 1;
                this.maxRadius = maxRadius;
                this.growthRate = 2;
                this.life = 1; 
                this.decay = 0.04; 
                this.color = color || '#ffffff';
                this.active = true;
            }

            update() {
                if (this.radius < this.maxRadius) {
                    this.radius += this.growthRate;
                } else {
                    this.life -= this.decay;
                }
                if (this.life <= 0) this.active = false;
            }

            draw() {
                // Desenha o flash branco inicial (maior)
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${this.life * 0.3})`;
                ctx.fill();
                
                // Desenha o núcleo de cor (mais pequeno)
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 0.7, 0, Math.PI * 2);
                ctx.fillStyle = this.color; 
                ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = this.life;
                ctx.fill();
                ctx.globalAlpha = 1.0;
                ctx.globalCompositeOperation = 'source-over';
            }
        }

        class EnemyMissile {
            constructor() {
                this.startX = Math.random() * width;
                this.startY = 0;
                this.x = this.startX;
                this.y = this.startY;
                
                let targetX;
                if (cities.some(c => c.active) && Math.random() > 0.3) {
                    const activeCities = cities.filter(c => c.active);
                    const targetCity = activeCities[Math.floor(Math.random() * activeCities.length)];
                    targetX = targetCity.x;
                } else {
                    targetX = Math.random() * width;
                }
                
                this.targetY = height;
                this.speed = ((Math.random() * 1.5 + 0.5) * difficultyMultiplier) * 0.7;
                
                const angle = Math.atan2(this.targetY - this.startY, targetX - this.startX);
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
                
                this.active = true;
                this.color = '#ff0055';
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                if (this.y >= height - 20) {
                    this.active = false;
                    createExplosion(this.x, height - 20, '#ffaa00', true); // Explosão na cidade
                    checkCityCollision(this.x);
                }
            }

            draw() {
                ctx.beginPath();
                ctx.moveTo(this.startX, this.startY);
                ctx.lineTo(this.x, this.y);
                ctx.strokeStyle = `rgba(255, 0, 85, 0.5)`;
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.fillRect(this.x - 1, this.y - 1, 3, 3);
            }
        }

        class PlayerMissile {
            constructor(targetX, targetY, type, angleOffset = 0) {
                this.startX = width / 2;
                this.startY = height - 20;
                this.x = this.startX;
                this.y = this.startY;
                this.targetX = targetX;
                this.targetY = targetY;
                this.type = type;
                this.active = true;
                
                this.creationTime = Date.now();
                this.target = null; 

                if (type === 1) { 
                    this.speed = 7.5; 
                    this.color = '#00ffff';
                } else if (type === 2) { 
                    this.speed = 3.92; 
                    this.color = '#00ff00';
                    this.turnSpeed = 0.016; 
                    this.maxFlightTime = 7000; 
                } else if (type === 3) { 
                    this.speed = 6;
                    this.color = '#ffff00';
                } else if (type === 4) { 
                    this.speed = 5; 
                    this.color = '#ff8800';
                }

                let angle = Math.atan2(targetY - this.startY, targetX - this.startX);
                angle += angleOffset;

                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
            }

            update() {
                if (this.type === 2) {
                    // Lógica de Tempo de Voo
                    if (Date.now() - this.creationTime > this.maxFlightTime) {
                        this.active = false;
                        createExplosion(this.x, this.y, this.color, false);
                        return;
                    }

                    // --- LÓGICA DE ALVO INTELIGENTE ---
                    if (!this.target || !this.target.active) {
                        this.target = null; 

                        const otherHomingMissiles = playerMissiles.filter(p => p !== this && p.active && p.type === 2 && p.target);
                        const busyTargets = otherHomingMissiles.map(p => p.target);

                        let candidates = enemyMissiles.filter(e => e.active && !busyTargets.includes(e));
                        if (candidates.length === 0) candidates = enemyMissiles.filter(e => e.active);

                        let closestDist = Infinity;
                        candidates.forEach(enemy => {
                            const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                            if (dist < closestDist) {
                                closestDist = dist;
                                this.target = enemy;
                            }
                        });
                    }

                    if (this.target) {
                        const targetAngle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                        const currentAngle = Math.atan2(this.vy, this.vx);

                        let angleDiff = targetAngle - currentAngle;
                        while (angleDiff <= -Math.PI) angleDiff += Math.PI * 2;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;

                        let newAngle = currentAngle;
                        if (Math.abs(angleDiff) < this.turnSpeed) {
                            newAngle = targetAngle;
                        } else {
                            newAngle += Math.sign(angleDiff) * this.turnSpeed;
                        }

                        this.vx = Math.cos(newAngle) * this.speed;
                        this.vy = Math.sin(newAngle) * this.speed;
                    }
                }

                this.x += this.vx;
                this.y += this.vy;

                if (this.type === 1) {
                    const distToTarget = Math.hypot(this.x - this.targetX, this.y - this.targetY);
                    if (distToTarget < this.speed || (this.vy < 0 && this.y <= this.targetY)) {
                        this.active = false;
                        createExplosion(this.targetX, this.targetY, this.color, false);
                    }
                } else {
                    if (this.x < 0 || this.x > width || this.y < 0 || this.y > height) {
                        this.active = false;
                    }
                }
            }

            draw() {
                ctx.beginPath();
                if (this.type === 1 || this.type === 4) {
                    ctx.moveTo(this.startX, this.startY);
                    ctx.lineTo(this.x, this.y);
                } else {
                    ctx.moveTo(this.x - this.vx * 3, this.y - this.vy * 3);
                    ctx.lineTo(this.x, this.y);
                }
                
                ctx.strokeStyle = this.color;
                ctx.lineWidth = (this.type === 3) ? 1 : (this.type === 4 ? 3 : 2);
                ctx.stroke();

                ctx.fillStyle = '#fff';
                const size = this.type === 3 ? 2 : 3;
                ctx.fillRect(this.x - size/2, this.y - size/2, size, size);
            }
        }

        // Funções Auxiliares

        function initCities() {
            cities = [];
            const spacing = width / 7;
            for (let i = 1; i <= 6; i++) {
                cities.push(new City(spacing * i));
            }
        }

        function attemptFire(x, y) {
            const now = Date.now();

            if (selectedWeapon === 2) {
                const activeHoming = playerMissiles.filter(p => p.active && p.type === 2).length;
                if (activeHoming >= 4) return; 
                fireMissile(x, y, 2);
            }
            else if (selectedWeapon === 3) {
                if (mgOverheated) return; 
                if (now - lastShotTime > 100) {
                    if (mgAmmo > 0) {
                        mgAmmo--;
                        fireMissile(x, y, 3);
                        lastShotTime = now;
                        updateMgUI();
                    }
                    if (mgAmmo <= 0 && !mgOverheated) {
                        startMgCooldown();
                    }
                }
            }
            else if (selectedWeapon === 4) {
                if (now - cannonLastShot > cannonCooldown) {
                    fireCannonSpread(x, y);
                    cannonLastShot = now;
                }
            }
            else if (selectedWeapon === 5) { 
                if (now - laserLastShot > laserCooldown) {
                    fireLaser(x, y);
                    laserLastShot = now;
                }
            }
            else {
                fireMissile(x, y, 1);
            }
        }

        function startMgCooldown() {
            mgOverheated = true;
            updateMgUI();
            setTimeout(() => {
                mgAmmo = mgMaxAmmo;
                mgOverheated = false;
                updateMgUI();
            }, 2000); 
        }

        function fireMissile(x, y, type) {
            if (y > height - 50) y = height - 50;
            
            if (type === 3) {
                x += (Math.random() * 40 - 20);
                y += (Math.random() * 40 - 20);
            }
            
            playerMissiles.push(new PlayerMissile(x, y, type));
        }

        function fireCannonSpread(targetX, targetY) {
            if (targetY > height - 50) targetY = height - 50;
            const spreadAngles = [-0.2, -0.1, 0, 0.1, 0.2];
            spreadAngles.forEach(angleOffset => {
                playerMissiles.push(new PlayerMissile(targetX, targetY, 4, angleOffset));
            });
        }

        function fireLaser(x, y) {
            lasers.push(new LaserBeam(x, y));
        }

        function createExplosion(x, y, color, isGroundImpact = false) {
            const radius = isGroundImpact ? 80 : 70; // Explosões no chão são maiores
            explosions.push(new Explosion(x, y, color, radius));
            
            // Adiciona 50 partículas de detritos (Branco/Cor base)
            for(let i=0; i<50; i++) {
                particles.push(new Particle(x, y, color));
            }

            // Adiciona 30 partículas de Fogo (vermelho/amarelo)
            for(let i=0; i<30; i++) {
                particles.push(new FireParticle(x, y));
            }

            // Adiciona 20 partículas de Fumo (cinzento)
            for(let i=0; i<20; i++) {
                particles.push(new SmokeParticle(x, y));
            }
        }

        function checkCityCollision(impactX) {
            cities.forEach(city => {
                if (city.active && Math.abs(impactX - city.x) < 30) {
                    city.active = false;
                    for(let k=0; k<5; k++) {
                        setTimeout(() => {
                            // Cria explosões secundárias nas cidades destruídas com fogo e fumo
                            createExplosion(city.x + (Math.random()*20-10), city.y - (Math.random()*10), '#ff0000', true);
                        }, k * 100);
                    }
                }
            });
        }

        function distToSegment(p, v, w) {
            function sqr(x) { return x * x }
            function dist2(v, w) { return sqr(v.x - w.x) + sqr(v.y - w.y) }
            let l2 = dist2(v, w);
            if (l2 == 0) return Math.sqrt(dist2(p, v));
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            return Math.sqrt(dist2(p, { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) }));
        }

        function checkCollisions() {
            // 1. Explosões
            explosions.forEach(exp => {
                if (!exp.active) return;
                enemyMissiles.forEach(enemy => {
                    if (!enemy.active) return;
                    const dist = Math.hypot(enemy.x - exp.x, enemy.y - exp.y);
                    if (dist < exp.radius) {
                        enemy.active = false;
                        score += 100;
                        createExplosion(enemy.x, enemy.y, '#ffaa00', false);
                    }
                });
            });

            // 2. Mísseis Físicos
            playerMissiles.forEach(pm => {
                if (!pm.active || pm.type === 1) return;
                
                enemyMissiles.forEach(enemy => {
                    if (!enemy.active) return;
                    const dist = Math.hypot(pm.x - enemy.x, pm.y - enemy.y);
                    const hitRadius = (pm.type === 4) ? 25 : 15;

                    if (dist < hitRadius) {
                        enemy.active = false;
                        pm.active = false; 
                        score += 150;
                        createExplosion(enemy.x, enemy.y, '#ffaa00', false);
                    }
                });
            });

            // 3. Lasers
            lasers.forEach(laser => {
                if (!laser.active) return;
                enemyMissiles.forEach(enemy => {
                    if (!enemy.active) return;
                    
                    const dist = distToSegment(
                        {x: enemy.x, y: enemy.y}, 
                        {x: laser.startX, y: laser.startY}, 
                        {x: laser.endX, y: laser.endY}
                    );

                    if (dist < 10) { 
                        enemy.active = false;
                        score += 200; 
                        createExplosion(enemy.x, enemy.y, '#ff00ff', false); 
                    }
                });
            });
        }

        function resetGame() {
            score = 0;
            difficultyMultiplier = 1;
            frameCount = 0;
            enemyMissiles = [];
            playerMissiles = [];
            explosions = [];
            particles = [];
            lasers = [];
            
            mgAmmo = mgMaxAmmo;
            mgOverheated = false;
            updateMgUI();
            cannonLastShot = 0;
            laserLastShot = 0;

            initCities();
            gameOver = false;
            loop();
        }

        function updateScore() {
            document.getElementById('score-display').innerText = `PONTUAÇÃO: ${score}`;
        }

        function loop() {
            if (gameOver) return;
            
            // Rastro
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, width, height);

            if (isMouseDown && selectedWeapon === 3) {
                attemptFire(mouse.x, mouse.y);
            }

            if (cities.every(c => !c.active)) {
                gameOver = true;
                ctx.fillStyle = 'white';
                ctx.font = '40px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText("FIM DE JOGO", width/2, height/2);
                ctx.font = '20px Courier New';
                ctx.fillText("Clique para Reiniciar", width/2, height/2 + 40);
                return;
            }

            if (frameCount % Math.max(20, 100 - Math.floor(score/500)) === 0) {
                enemyMissiles.push(new EnemyMissile());
                difficultyMultiplier = 1 + (score / 5000);
            }

            // A ordem de desenho é crucial para o efeito de fogo/fumo.
            
            // 1. Partículas (Fumo/Fogo/Detritos)
            particles.forEach((p, index) => {
                p.update();
                p.draw();
                if (!p.active) particles.splice(index, 1);
            });
            
            // 2. Explosões (Núcleo Brilhante)
            explosions.forEach((e, index) => {
                e.update();
                e.draw();
                if (!e.active) explosions.splice(index, 1);
            });

            // 3. Mísseis e Laser (Em cima de tudo)
            lasers.forEach((l, index) => {
                l.update();
                l.draw();
                if (!l.active) lasers.splice(index, 1);
            });

            enemyMissiles.forEach((m, index) => {
                m.update();
                m.draw();
                if (!m.active) enemyMissiles.splice(index, 1);
            });

            playerMissiles.forEach((m, index) => {
                m.update();
                m.draw();
                if (!m.active) playerMissiles.splice(index, 1);
            });

            // 4. Cidades e Base
            cities.forEach(city => city.draw());
            ctx.fillStyle = '#0088ff';
            ctx.beginPath();
            ctx.arc(width/2, height-10, 20, Math.PI, 0);
            ctx.fill();
            ctx.fillStyle = '#333';
            ctx.fillRect(0, height-20, width, 20);

            checkCollisions();
            updateScore();
            frameCount++;
            requestAnimationFrame(loop);
        }

        resize();
        initCities();
        updateMgUI();
        loop();

    </script>
</body>
</html><!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Defesa de Mísseis - Arsenal Tático</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
            color: #fff;
            user-select: none;
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            text-shadow: 0 0 5px #fff;
            z-index: 10;
        }
        h1 {
            margin: 0;
            font-size: 24px;
            color: #0ff;
        }
        p {
            margin: 5px 0;
            color: #aaa;
        }
        #score-display {
            font-size: 20px;
            color: #ff0;
        }
        #weapon-select {
            margin-top: 15px;
            background: rgba(0, 20, 40, 0.7);
            padding: 10px;
            border: 1px solid #0ff;
            border-radius: 5px;
            pointer-events: auto;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .weapon {
            padding: 5px 10px;
            border: 1px solid #555;
            font-size: 14px;
            color: #777;
            cursor: pointer;
            text-align: center;
        }
        .weapon.active {
            color: #fff;
            background-color: #0055aa;
            border-color: #0ff;
            box-shadow: 0 0 10px #0ff;
        }
        .key-hint {
            font-size: 10px;
            color: #aaa;
            display: block;
            margin-top: 2px;
        }
        
        #mg-status {
            margin-top: 10px;
            height: 10px;
            width: 100%;
            background: #333;
            display: none;
            border: 1px solid #555;
        }
        #mg-bar {
            height: 100%;
            width: 100%;
            background: #ff0;
            transition: width 0.1s linear;
        }
        .reloading #mg-bar {
            background: #f00;
        }
        #status-text {
            font-size: 12px;
            margin-top: 2px;
            color: #aaa;
        }
    </style>
</head>
<body>

    <div id="ui">
        <h1>DEFESA PLANETÁRIA</h1>
        <p>Clique para disparar.</p>
        <div id="score-display">PONTUAÇÃO: 0</div>
        
        <div id="weapon-select">
            <div id="w1" class="weapon active" onclick="setWeapon(1)">
                PADRÃO
                <span class="key-hint">[1]</span>
            </div>
            <div id="w2" class="weapon" onclick="setWeapon(2)">
                TELEGUIADO
                <span class="key-hint">[2]</span>
            </div>
            <div id="w3" class="weapon" onclick="setWeapon(3)">
                METRALHADORA
                <span class="key-hint">[3]</span>
            </div>
            <div id="w4" class="weapon" onclick="setWeapon(4)">
                CANHÃO
                <span class="key-hint">[4]</span>
            </div>
            <div id="w5" class="weapon" onclick="setWeapon(5)">
                LASER
                <span class="key-hint">[5]</span>
            </div>
        </div>

        <div id="mg-status">
            <div id="mg-bar"></div>
        </div>
        <div id="status-text"></div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let score = 0;
        let gameOver = false;
        let frameCount = 0;
        let difficultyMultiplier = 1;

        // Estados de Input e Armas
        let selectedWeapon = 1; 
        let isMouseDown = false;
        let lastShotTime = 0;

        // Configurações Específicas de Armas
        let mgAmmo = 20;
        const mgMaxAmmo = 20;
        let mgOverheated = false;
        
        let cannonLastShot = 0;
        const cannonCooldown = 1000; 
        
        let laserLastShot = 0;
        const laserCooldown = 3000; 

        // Entidades do Jogo
        let cities = [];
        let enemyMissiles = [];
        let playerMissiles = [];
        let explosions = [];
        let particles = []; 
        let lasers = []; 
        
        const mouse = { x: 0, y: 0 };

        window.addEventListener('resize', resize);
        
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        window.addEventListener('keydown', e => {
            if (['1', '2', '3', '4', '5'].includes(e.key)) {
                setWeapon(parseInt(e.key));
            }
        });

        window.addEventListener('mousedown', e => {
            if (gameOver) {
                resetGame();
            } else {
                isMouseDown = true;
                if (selectedWeapon !== 3) {
                    attemptFire(e.clientX, e.clientY);
                }
            }
        });

        window.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        function setWeapon(type) {
            selectedWeapon = type;
            document.querySelectorAll('.weapon').forEach(el => el.classList.remove('active'));
            document.getElementById('w' + type).classList.add('active');
            
            const mgStatus = document.getElementById('mg-status');
            const statusText = document.getElementById('status-text');
            
            if (type === 3) {
                mgStatus.style.display = 'block';
                updateMgUI();
            } else {
                mgStatus.style.display = 'none';
                statusText.innerText = "";
            }

            if (type === 2) {
                statusText.innerText = "Max: 4 | Tempo Limite: 7s | Alvos Inteligentes";
            } else if (type === 4) {
                statusText.innerText = "Cooldown: 1 segundo";
            } else if (type === 5) {
                statusText.innerText = "Cooldown: 3 segundos | Instakill";
            } else if (type === 1) {
                statusText.innerText = "Velocidade: Standard (Reduzida)";
            }
        }

        function updateMgUI() {
            if (selectedWeapon !== 3) return;
            
            const bar = document.getElementById('mg-bar');
            const text = document.getElementById('status-text');
            const container = document.getElementById('mg-status');
            
            const pct = (mgAmmo / mgMaxAmmo) * 100;
            bar.style.width = pct + '%';
            
            if (mgOverheated) {
                container.classList.add('reloading');
                text.innerText = "SOBREAQUECIMENTO - A ARREFECER...";
                text.style.color = '#f00';
            } else {
                container.classList.remove('reloading');
                text.innerText = `MUNIÇÃO: ${mgAmmo}/${mgMaxAmmo}`;
                text.style.color = '#aaa';
            }
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            if (cities.length > 0) initCities();
        }

        class City {
            constructor(x) {
                this.x = x;
                this.y = height - 40;
                this.width = 40;
                this.height = 20;
                this.active = true;
                this.color = '#00ffff';
            }

            draw() {
                if (!this.active) return;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.fillRect(this.x - this.width/2, this.y, this.width, this.height);
                
                ctx.fillStyle = '#000';
                ctx.shadowBlur = 0;
                ctx.fillRect(this.x - 10, this.y + 5, 4, 4);
                ctx.fillRect(this.x + 5, this.y + 5, 4, 4);
            }
        }

        class LaserBeam {
            constructor(targetX, targetY) {
                this.startX = width / 2;
                this.startY = height - 20;
                
                const angle = Math.atan2(targetY - this.startY, targetX - this.startX);
                
                const length = Math.max(width, height) * 1.5;
                this.endX = this.startX + Math.cos(angle) * length;
                this.endY = this.startY + Math.sin(angle) * length;
                
                this.life = 1.0; 
                this.decay = 0.012; // Aumenta o tempo de ação do laser
                this.active = true;
                this.width = 4;
            }

            update() {
                this.life -= this.decay;
                if (this.life <= 0) this.active = false;
            }

            draw() {
                if (!this.active) return;
                
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.globalCompositeOperation = 'lighter';
                
                ctx.beginPath();
                ctx.moveTo(this.startX, this.startY);
                ctx.lineTo(this.endX, this.endY);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = this.width;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(this.startX, this.startY);
                ctx.lineTo(this.endX, this.endY);
                ctx.strokeStyle = '#ff00ff'; 
                ctx.lineWidth = this.width * 4;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ff00ff';
                ctx.stroke();
                
                ctx.restore();
            }
        }
        
        // Classe de Partículas Base (Detritos)
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 4 + 1; 
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1; 
                this.decay = Math.random() * 0.03 + 0.01; 
                this.color = color;
                this.active = true;
                this.gravity = 0.08; 
                this.size = 3;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                
                this.vy += this.gravity; 
                this.vx *= 0.95; 
                this.vy *= 0.95; 

                this.life -= this.decay;
                if (this.life <= 0) this.active = false;
            }

            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1.0;
            }
        }

        // Nova Classe de Partículas: Fogo/Chama
        class FireParticle extends Particle {
            constructor(x, y) {
                // Chama o construtor base, mas força cor amarela/laranja
                super(x, y, `rgb(${255}, ${Math.floor(Math.random() * 150 + 100)}, 0)`);
                this.vy = Math.random() * -3 - 1; // Fogo sobe mais rápido
                this.vx /= 2; // Movimento horizontal mais lento
                this.gravity = -0.05; // Leve ascensão
                this.decay = 0.04;
                this.size = Math.random() * 4 + 2;
            }

            update() {
                super.update();
                // O fogo deve encolher
                this.size = Math.max(0.5, this.size - 0.1); 
            }
        }

        // Nova Classe de Partículas: Fumo
        class SmokeParticle extends Particle {
            constructor(x, y) {
                // Fumo é cinzento
                const gray = Math.floor(Math.random() * 50 + 50);
                super(x, y, `rgb(${gray}, ${gray}, ${gray})`);
                this.vy /= 5; // Move-se devagar
                this.gravity = 0; // Quase sem gravidade
                this.decay = 0.01; // Dura muito mais
                this.size = Math.random() * 5 + 3;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.99;
                this.vy *= 0.99;
                
                // O fumo deve expandir-se
                this.size += 0.1; 
                
                this.life -= this.decay;
                if (this.life <= 0) this.active = false;
            }

            draw() {
                ctx.globalAlpha = Math.max(0, this.life * 0.5); // Fumo é translúcido
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class Explosion {
            constructor(x, y, color, maxRadius = 70) { // Aumenta ligeiramente o raio
                this.x = x;
                this.y = y;
                this.radius = 1;
                this.maxRadius = maxRadius;
                this.growthRate = 2;
                this.life = 1; 
                this.decay = 0.04; 
                this.color = color || '#ffffff';
                this.active = true;
            }

            update() {
                if (this.radius < this.maxRadius) {
                    this.radius += this.growthRate;
                } else {
                    this.life -= this.decay;
                }
                if (this.life <= 0) this.active = false;
            }

            draw() {
                // Desenha o flash branco inicial (maior)
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${this.life * 0.3})`;
                ctx.fill();
                
                // Desenha o núcleo de cor (mais pequeno)
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 0.7, 0, Math.PI * 2);
                ctx.fillStyle = this.color; 
                ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = this.life;
                ctx.fill();
                ctx.globalAlpha = 1.0;
                ctx.globalCompositeOperation = 'source-over';
            }
        }

        class EnemyMissile {
            constructor() {
                this.startX = Math.random() * width;
                this.startY = 0;
                this.x = this.startX;
                this.y = this.startY;
                
                let targetX;
                if (cities.some(c => c.active) && Math.random() > 0.3) {
                    const activeCities = cities.filter(c => c.active);
                    const targetCity = activeCities[Math.floor(Math.random() * activeCities.length)];
                    targetX = targetCity.x;
                } else {
                    targetX = Math.random() * width;
                }
                
                this.targetY = height;
                this.speed = ((Math.random() * 1.5 + 0.5) * difficultyMultiplier) * 0.7;
                
                const angle = Math.atan2(this.targetY - this.startY, targetX - this.startX);
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
                
                this.active = true;
                this.color = '#ff0055';
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                if (this.y >= height - 20) {
                    this.active = false;
                    createExplosion(this.x, height - 20, '#ffaa00', true); // Explosão na cidade
                    checkCityCollision(this.x);
                }
            }

            draw() {
                ctx.beginPath();
                ctx.moveTo(this.startX, this.startY);
                ctx.lineTo(this.x, this.y);
                ctx.strokeStyle = `rgba(255, 0, 85, 0.5)`;
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.fillRect(this.x - 1, this.y - 1, 3, 3);
            }
        }

        class PlayerMissile {
            constructor(targetX, targetY, type, angleOffset = 0) {
                this.startX = width / 2;
                this.startY = height - 20;
                this.x = this.startX;
                this.y = this.startY;
                this.targetX = targetX;
                this.targetY = targetY;
                this.type = type;
                this.active = true;
                
                this.creationTime = Date.now();
                this.target = null; 

                if (type === 1) { 
                    this.speed = 7.5; 
                    this.color = '#00ffff';
                } else if (type === 2) { 
                    this.speed = 3.92; 
                    this.color = '#00ff00';
                    this.turnSpeed = 0.016; 
                    this.maxFlightTime = 7000; 
                } else if (type === 3) { 
                    this.speed = 6;
                    this.color = '#ffff00';
                } else if (type === 4) { 
                    this.speed = 5; 
                    this.color = '#ff8800';
                }

                let angle = Math.atan2(targetY - this.startY, targetX - this.startX);
                angle += angleOffset;

                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
            }

            update() {
                if (this.type === 2) {
                    // Lógica de Tempo de Voo
                    if (Date.now() - this.creationTime > this.maxFlightTime) {
                        this.active = false;
                        createExplosion(this.x, this.y, this.color, false);
                        return;
                    }

                    // --- LÓGICA DE ALVO INTELIGENTE ---
                    if (!this.target || !this.target.active) {
                        this.target = null; 

                        const otherHomingMissiles = playerMissiles.filter(p => p !== this && p.active && p.type === 2 && p.target);
                        const busyTargets = otherHomingMissiles.map(p => p.target);

                        let candidates = enemyMissiles.filter(e => e.active && !busyTargets.includes(e));
                        if (candidates.length === 0) candidates = enemyMissiles.filter(e => e.active);

                        let closestDist = Infinity;
                        candidates.forEach(enemy => {
                            const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                            if (dist < closestDist) {
                                closestDist = dist;
                                this.target = enemy;
                            }
                        });
                    }

                    if (this.target) {
                        const targetAngle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                        const currentAngle = Math.atan2(this.vy, this.vx);

                        let angleDiff = targetAngle - currentAngle;
                        while (angleDiff <= -Math.PI) angleDiff += Math.PI * 2;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;

                        let newAngle = currentAngle;
                        if (Math.abs(angleDiff) < this.turnSpeed) {
                            newAngle = targetAngle;
                        } else {
                            newAngle += Math.sign(angleDiff) * this.turnSpeed;
                        }

                        this.vx = Math.cos(newAngle) * this.speed;
                        this.vy = Math.sin(newAngle) * this.speed;
                    }
                }

                this.x += this.vx;
                this.y += this.vy;

                if (this.type === 1) {
                    const distToTarget = Math.hypot(this.x - this.targetX, this.y - this.targetY);
                    if (distToTarget < this.speed || (this.vy < 0 && this.y <= this.targetY)) {
                        this.active = false;
                        createExplosion(this.targetX, this.targetY, this.color, false);
                    }
                } else {
                    if (this.x < 0 || this.x > width || this.y < 0 || this.y > height) {
                        this.active = false;
                    }
                }
            }

            draw() {
                ctx.beginPath();
                if (this.type === 1 || this.type === 4) {
                    ctx.moveTo(this.startX, this.startY);
                    ctx.lineTo(this.x, this.y);
                } else {
                    ctx.moveTo(this.x - this.vx * 3, this.y - this.vy * 3);
                    ctx.lineTo(this.x, this.y);
                }
                
                ctx.strokeStyle = this.color;
                ctx.lineWidth = (this.type === 3) ? 1 : (this.type === 4 ? 3 : 2);
                ctx.stroke();

                ctx.fillStyle = '#fff';
                const size = this.type === 3 ? 2 : 3;
                ctx.fillRect(this.x - size/2, this.y - size/2, size, size);
            }
        }

        // Funções Auxiliares

        function initCities() {
            cities = [];
            const spacing = width / 7;
            for (let i = 1; i <= 6; i++) {
                cities.push(new City(spacing * i));
            }
        }

        function attemptFire(x, y) {
            const now = Date.now();

            if (selectedWeapon === 2) {
                const activeHoming = playerMissiles.filter(p => p.active && p.type === 2).length;
                if (activeHoming >= 4) return; 
                fireMissile(x, y, 2);
            }
            else if (selectedWeapon === 3) {
                if (mgOverheated) return; 
                if (now - lastShotTime > 100) {
                    if (mgAmmo > 0) {
                        mgAmmo--;
                        fireMissile(x, y, 3);
                        lastShotTime = now;
                        updateMgUI();
                    }
                    if (mgAmmo <= 0 && !mgOverheated) {
                        startMgCooldown();
                    }
                }
            }
            else if (selectedWeapon === 4) {
                if (now - cannonLastShot > cannonCooldown) {
                    fireCannonSpread(x, y);
                    cannonLastShot = now;
                }
            }
            else if (selectedWeapon === 5) { 
                if (now - laserLastShot > laserCooldown) {
                    fireLaser(x, y);
                    laserLastShot = now;
                }
            }
            else {
                fireMissile(x, y, 1);
            }
        }

        function startMgCooldown() {
            mgOverheated = true;
            updateMgUI();
            setTimeout(() => {
                mgAmmo = mgMaxAmmo;
                mgOverheated = false;
                updateMgUI();
            }, 2000); 
        }

        function fireMissile(x, y, type) {
            if (y > height - 50) y = height - 50;
            
            if (type === 3) {
                x += (Math.random() * 40 - 20);
                y += (Math.random() * 40 - 20);
            }
            
            playerMissiles.push(new PlayerMissile(x, y, type));
        }

        function fireCannonSpread(targetX, targetY) {
            if (targetY > height - 50) targetY = height - 50;
            const spreadAngles = [-0.2, -0.1, 0, 0.1, 0.2];
            spreadAngles.forEach(angleOffset => {
                playerMissiles.push(new PlayerMissile(targetX, targetY, 4, angleOffset));
            });
        }

        function fireLaser(x, y) {
            lasers.push(new LaserBeam(x, y));
        }

        function createExplosion(x, y, color, isGroundImpact = false) {
            const radius = isGroundImpact ? 80 : 70; // Explosões no chão são maiores
            explosions.push(new Explosion(x, y, color, radius));
            
            // Adiciona 50 partículas de detritos (Branco/Cor base)
            for(let i=0; i<50; i++) {
                particles.push(new Particle(x, y, color));
            }

            // Adiciona 30 partículas de Fogo (vermelho/amarelo)
            for(let i=0; i<30; i++) {
                particles.push(new FireParticle(x, y));
            }

            // Adiciona 20 partículas de Fumo (cinzento)
            for(let i=0; i<20; i++) {
                particles.push(new SmokeParticle(x, y));
            }
        }

        function checkCityCollision(impactX) {
            cities.forEach(city => {
                if (city.active && Math.abs(impactX - city.x) < 30) {
                    city.active = false;
                    for(let k=0; k<5; k++) {
                        setTimeout(() => {
                            // Cria explosões secundárias nas cidades destruídas com fogo e fumo
                            createExplosion(city.x + (Math.random()*20-10), city.y - (Math.random()*10), '#ff0000', true);
                        }, k * 100);
                    }
                }
            });
        }

        function distToSegment(p, v, w) {
            function sqr(x) { return x * x }
            function dist2(v, w) { return sqr(v.x - w.x) + sqr(v.y - w.y) }
            let l2 = dist2(v, w);
            if (l2 == 0) return Math.sqrt(dist2(p, v));
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            return Math.sqrt(dist2(p, { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) }));
        }

        function checkCollisions() {
            // 1. Explosões
            explosions.forEach(exp => {
                if (!exp.active) return;
                enemyMissiles.forEach(enemy => {
                    if (!enemy.active) return;
                    const dist = Math.hypot(enemy.x - exp.x, enemy.y - exp.y);
                    if (dist < exp.radius) {
                        enemy.active = false;
                        score += 100;
                        createExplosion(enemy.x, enemy.y, '#ffaa00', false);
                    }
                });
            });

            // 2. Mísseis Físicos
            playerMissiles.forEach(pm => {
                if (!pm.active || pm.type === 1) return;
                
                enemyMissiles.forEach(enemy => {
                    if (!enemy.active) return;
                    const dist = Math.hypot(pm.x - enemy.x, pm.y - enemy.y);
                    const hitRadius = (pm.type === 4) ? 25 : 15;

                    if (dist < hitRadius) {
                        enemy.active = false;
                        pm.active = false; 
                        score += 150;
                        createExplosion(enemy.x, enemy.y, '#ffaa00', false);
                    }
                });
            });

            // 3. Lasers
            lasers.forEach(laser => {
                if (!laser.active) return;
                enemyMissiles.forEach(enemy => {
                    if (!enemy.active) return;
                    
                    const dist = distToSegment(
                        {x: enemy.x, y: enemy.y}, 
                        {x: laser.startX, y: laser.startY}, 
                        {x: laser.endX, y: laser.endY}
                    );

                    if (dist < 10) { 
                        enemy.active = false;
                        score += 200; 
                        createExplosion(enemy.x, enemy.y, '#ff00ff', false); 
                    }
                });
            });
        }

        function resetGame() {
            score = 0;
            difficultyMultiplier = 1;
            frameCount = 0;
            enemyMissiles = [];
            playerMissiles = [];
            explosions = [];
            particles = [];
            lasers = [];
            
            mgAmmo = mgMaxAmmo;
            mgOverheated = false;
            updateMgUI();
            cannonLastShot = 0;
            laserLastShot = 0;

            initCities();
            gameOver = false;
            loop();
        }

        function updateScore() {
            document.getElementById('score-display').innerText = `PONTUAÇÃO: ${score}`;
        }

        function loop() {
            if (gameOver) return;
            
            // Rastro
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, width, height);

            if (isMouseDown && selectedWeapon === 3) {
                attemptFire(mouse.x, mouse.y);
            }

            if (cities.every(c => !c.active)) {
                gameOver = true;
                ctx.fillStyle = 'white';
                ctx.font = '40px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText("FIM DE JOGO", width/2, height/2);
                ctx.font = '20px Courier New';
                ctx.fillText("Clique para Reiniciar", width/2, height/2 + 40);
                return;
            }

            if (frameCount % Math.max(20, 100 - Math.floor(score/500)) === 0) {
                enemyMissiles.push(new EnemyMissile());
                difficultyMultiplier = 1 + (score / 5000);
            }

            // A ordem de desenho é crucial para o efeito de fogo/fumo.
            
            // 1. Partículas (Fumo/Fogo/Detritos)
            particles.forEach((p, index) => {
                p.update();
                p.draw();
                if (!p.active) particles.splice(index, 1);
            });
            
            // 2. Explosões (Núcleo Brilhante)
            explosions.forEach((e, index) => {
                e.update();
                e.draw();
                if (!e.active) explosions.splice(index, 1);
            });

            // 3. Mísseis e Laser (Em cima de tudo)
            lasers.forEach((l, index) => {
                l.update();
                l.draw();
                if (!l.active) lasers.splice(index, 1);
            });

            enemyMissiles.forEach((m, index) => {
                m.update();
                m.draw();
                if (!m.active) enemyMissiles.splice(index, 1);
            });

            playerMissiles.forEach((m, index) => {
                m.update();
                m.draw();
                if (!m.active) playerMissiles.splice(index, 1);
            });

            // 4. Cidades e Base
            cities.forEach(city => city.draw());
            ctx.fillStyle = '#0088ff';
            ctx.beginPath();
            ctx.arc(width/2, height-10, 20, Math.PI, 0);
            ctx.fill();
            ctx.fillStyle = '#333';
            ctx.fillRect(0, height-20, width, 20);

            checkCollisions();
            updateScore();
            frameCount++;
            requestAnimationFrame(loop);
        }

        resize();
        initCities();
        updateMgUI();
        loop();

    </script>
</body>
</html>